# TUGAS 7

1. Apa itu Widget Tree dan Hubungan Parent-Child? 

Widget tree (pohon widget) adalah representasi dari keseluruhan struktur antarmuka pengguna (UI) aplikasi Flutter Anda. Karena di Flutter "segalanya adalah widget", UI dibangun dengan menyusun widget di dalam widget lain, yang secara alami membentuk struktur pohon. Hubungan parent-child (induk-anak) adalah inti dari konsep ini. Parent adalah widget yang berisi widget lain (disebut children). Parent bertanggung jawab untuk mengonfigurasi dan memposisikan children-nya. Sebagai contoh, dalam kode Anda, Scaffold adalah parent dari AppBar dan Padding, dan Column adalah parent yang mengatur Row dan Center secara vertikal. Hubungan inilah yang menentukan tata letak dan hierarki visual aplikasi.

2. Widget yang Digunakan dalam Proyek 

Proyek ini menggunakan berbagai widget untuk membangun halaman utama. MyApp adalah StatelessWidget kustom yang berfungsi sebagai root aplikasi dan mengembalikan MaterialApp. MaterialApp adalah widget inti yang menyediakan tema (ThemeData), judul, dan properti home yang diatur ke MyHomePage. MyHomePage (sebuah StatelessWidget) menggunakan Scaffold untuk menyediakan struktur halaman dasar, termasuk AppBar untuk bilah judul dan body untuk konten utama. Di dalam body, Padding digunakan untuk memberi jarak di sekitar konten, yang kemudian diatur oleh Column (untuk susunan vertikal) dan Row (untuk susunan horizontal). Row digunakan untuk menampilkan tiga InfoCard kustom (yang menggunakan Card untuk menampilkan data seperti NPM, Nama, dan Kelas). Widget Center digunakan untuk memusatkan GridView.count, yang bertanggung jawab untuk menyusun ItemCard dalam format grid 3-kolom. ItemCard adalah StatelessWidget kustom yang menggunakan Material untuk memberi warna latar belakang dan borderRadius, serta InkWell untuk mendeteksi ketukan (tap). Saat diketuk, InkWell memanggil ScaffoldMessenger untuk menampilkan SnackBar dengan pesan yang relevan. Widget dasar lainnya seperti Text, Icon, dan SizedBox digunakan untuk menampilkan teks, ikon, dan memberikan jarak antar elemen.

3. Fungsi MaterialApp dan Mengapa Sering Jadi Root 

Fungsi utama MaterialApp adalah sebagai widget pembungkus tingkat atas yang menyediakan fungsionalitas dan styling standar Material Design untuk seluruh aplikasi. Ini mencakup penetapan tema global melalui properti theme, manajemen navigasi (perpindahan halaman), dan penetapan widget home (layar awal). MaterialApp sering digunakan sebagai widget root karena ia menyediakan BuildContext fundamental yang diperlukan oleh banyak widget Material Design lainnya. Widget seperti Scaffold, Theme, Navigator, dan Dialog bergantung pada MaterialApp sebagai "leluhur" mereka di dalam widget tree untuk dapat berfungsi dengan benar, misalnya untuk mengambil skema warna tema atau untuk mengelola tumpukan halaman.

4. Perbedaan StatelessWidget dan StatefulWidget 

Perbedaan utama antara StatelessWidget dan StatefulWidget terletak pada pengelolaan "state" (data internal). StatelessWidget bersifat immutable (tidak bisa berubah); propertinya diatur oleh parent-nya dan tidak pernah berubah selama lifecycle widget tersebut. Seluruh widget kustom dalam proyek Anda (MyApp, MyHomePage, InfoCard, ItemCard) adalah StatelessWidget. Sebaliknya, StatefulWidget bersifat dinamis dan dapat mengelola state internal yang bisa berubah. Saat state internalnya berubah (misalnya melalui interaksi pengguna), fungsi setState() dipanggil untuk memberi tahu Flutter agar membangun ulang UI widget tersebut. Anda sebaiknya memilih StatelessWidget untuk UI yang statis (seperti ikon atau label) dan memilih StatefulWidget saat UI perlu diperbarui secara dinamis sebagai respons terhadap data internal atau input pengguna (seperti checkbox atau form).

5. Apa itu BuildContext dan Pentingnya 

BuildContext adalah objek yang diteruskan ke metode build setiap widget, yang berfungsi sebagai "penanda" atau referensi lokasi widget tersebut di dalam widget tree. Ini sangat penting karena BuildContext adalah cara bagi sebuah widget untuk berinteraksi dengan "leluhurnya" (widget parent di atasnya) untuk menemukan layanan atau data. Dalam proyek Anda, context digunakan secara krusial di beberapa tempat: Theme.of(context) digunakan untuk mengambil skema warna yang didefinisikan di MaterialApp; MediaQuery.of(context) digunakan untuk mendapatkan ukuran layar perangkat; dan ScaffoldMessenger.of(context) digunakan untuk menemukan Scaffold terdekat yang dapat menampilkan SnackBar.

6. Hot Reload vs. Hot Restart 

Hot reload dan hot restart adalah fitur yang mempercepat proses pengembangan di Flutter. Hot reload bekerja dengan menyuntikkan kode yang diperbarui ke dalam Dart Virtual Machine (VM) yang sedang berjalan. Ini memungkinkan Flutter untuk membangun ulang widget tree dengan cepat (biasanya dalam hitungan detik) sehingga Anda bisa melihat perubahan UI secara instan. Yang terpenting, hot reload mempertahankan state aplikasi (misalnya, data yang Anda ketik di form tidak akan hilang). Sebaliknya, hot restart akan menghancurkan Dart VM yang ada dan memulai ulang seluruh aplikasi dari awal. Ini akan me-reset seluruh state aplikasi ke nilai awalnya. Hot restart lebih lambat daripada hot reload dan biasanya hanya digunakan ketika perubahan kode terlalu besar untuk hot reload, seperti mengubah state global atau file main().

# TUGAS 8

1. Perbedaan Navigator.push() dan Navigator.pushReplacement()

Navigator.push() dan Navigator.pushReplacement() adalah dua metode navigasi fundamental di Flutter, namun dengan perilaku yang berbeda secara signifikan. Navigator.push() bekerja seperti menumpuk kartu; ia menambahkan halaman (route) baru di atas tumpukan navigasi yang ada. Ini berarti pengguna dapat menekan tombol "kembali" untuk kembali ke halaman sebelumnya. Sebaliknya, Navigator.pushReplacement() mengganti halaman saat ini di tumpukan dengan halaman baru. Akibatnya, halaman sebelumnya dihapus dari tumpukan, sehingga pengguna tidak dapat kembali ke sana.

Dalam aplikasi Football Shop ini, Navigator.push() sangat ideal digunakan saat berpindah dari halaman utama ke halaman "Tambah Produk", baik melalui tombol pada halaman utama maupun dari drawer. Ini memungkinkan pengguna untuk mengisi formulir dan kemudian kembali ke halaman utama dengan mudah setelah selesai. Di sisi lain, Navigator.pushReplacement() lebih cocok digunakan saat kembali dari drawer ke halaman utama. Penggunaan ini mencegah tumpukan halaman yang tidak perlu, karena jika pengguna berada di halaman utama dan memilih "Halaman Utama" lagi, tidak ada gunanya menumpuk halaman yang sama berulang kali.

2. Pemanfaatan Hirarki Widget untuk Konsistensi

Struktur halaman yang konsisten di seluruh aplikasi Football Shop dibangun menggunakan hirarki widget inti Flutter, yaitu Scaffold, AppBar, dan Drawer. Scaffold bertindak sebagai kerangka dasar untuk setiap halaman, menyediakan struktur visual standar yang mencakup AppBar di bagian atas dan body untuk konten utama. AppBar digunakan secara konsisten di setiap halaman untuk menampilkan judul halaman dan memberikan titik akses ke Drawer. Drawer (LeftDrawer) kemudian diimplementasikan sebagai widget terpisah dan dipanggil di setiap Scaffold, memastikan bahwa menu navigasi samping yang sama persis—dengan opsi "Halaman Utama", "Tambah Produk", dan "Lihat Produk"—selalu tersedia, tidak peduli di halaman mana pengguna berada. Dengan memanfaatkan kembali AppBar dan Drawer yang sama di dalam setiap Scaffold, aplikasi ini secara efisien menciptakan antarmuka yang familier dan mudah dinavigasi bagi pengguna.

3. Kelebihan Layout Widget pada Form

Dalam konteks desain antarmuka, penggunaan layout widget seperti Padding, SingleChildScrollView, dan GridView sangat krusial saat membangun formulir. Padding memberikan ruang visual di sekitar elemen input, mencegahnya menempel pada tepi layar atau widget lain, yang secara signifikan meningkatkan keterbacaan dan estetika. Contohnya, setiap TextFormField dalam formulir tambah produk dibungkus dengan Padding(padding: const EdgeInsets.all(8.0), ...) untuk memberikan "napas" pada tata letak. Selanjutnya, SingleChildScrollView adalah widget esensial yang membungkus seluruh Form. Fungsinya adalah memastikan semua elemen formulir tetap dapat diakses meskipun tidak muat di layar secara vertikal, misalnya saat keyboard muncul atau saat dilihat pada perangkat dengan layar lebih kecil. Ini mencegah error render overflow dan menjamin pengalaman pengguna yang mulus. Terakhir, widget seperti GridView (yang digunakan di halaman utama) menunjukkan bagaimana kita bisa menyusun elemen interaktif secara efisien. GridView memungkinkan penyusunan beberapa tombol menu dalam format grid yang rapi, yang jauh lebih terstruktur daripada menempatkannya secara manual.

4. Penyesuaian Warna Tema untuk Identitas Visual

Untuk menciptakan identitas visual yang konsisten sesuai dengan brand toko, aplikasi Football Shop memanfaatkan properti theme di dalam MaterialApp pada file main.dart. Secara spesifik, ThemeData digunakan untuk mendefinisikan skema warna global untuk seluruh aplikasi. Di dalam ThemeData, properti colorScheme diatur menggunakan ColorScheme.fromSwatch(primarySwatch: Colors.blue). Ini secara otomatis menetapkan Colors.blue sebagai warna primer utama yang akan digunakan oleh berbagai widget, seperti AppBar. Dengan mendefinisikan warna tema di satu lokasi pusat ini, setiap AppBar atau komponen lain yang menggunakan warna primer tema akan secara otomatis mengadopsi warna biru yang telah ditentukan. Hal ini memastikan konsistensi visual di semua halaman dan memperkuat identitas merek "Football Shop" tanpa perlu mengatur warna secara manual pada setiap widget satu per satu.

# TUGAS 9

1.  Model Data dan Konsekuensi Pemetaan Langsung

Kita perlu secara eksplisit mendefinisikan **Model Dart** seperti `ProductEntry` (`lib/models/product_entry.dart`) saat mengambil atau mengirim data JSON karena model ini berfungsi sebagai **kontrak data** yang jelas, mendefinisikan secara pasti struktur, nama *field*, dan tipe data yang diharapkan dari *response* JSON dari Django. Konsekuensinya jika kita hanya memetakan langsung ke `Map<String, dynamic>` tanpa model adalah hilangnya perlindungan **null-safety** dan **validasi tipe** yang kuat, yang rentan menyebabkan *runtime error* (aplikasi *crash*) saat mencoba mengakses data dengan tipe yang salah atau nilai `null` di tahap eksekusi. Selain itu, **maintainability** kode akan sangat menurun karena setiap perubahan pada struktur API Django memerlukan perbaikan manual di puluhan lokasi yang menggunakan *Map* tersebut, bukan hanya di satu file model.

---

2. Fungsi Package `http` dan `CookieRequest`

Dalam tugas ini, kita memanfaatkan dua *package* jaringan: **`http`** dan **`pbp_django_auth` (`CookieRequest`)**. *Package* **`http`** menyediakan fungsi dasar untuk semua *request* HTTP (GET, POST), menangani koneksi dan pertukaran data mentah. Sementara itu, **`CookieRequest`** adalah *wrapper* yang dibuat khusus di atas `http` untuk mengelola **sesi Django** secara otomatis. Peran utama `CookieRequest` adalah untuk menangkap dan menyimpan *session cookie* Django yang diterima setelah *login* berhasil, dan kemudian secara otomatis menyertakan *cookie* ini di *header* setiap *request* berikutnya yang bertujuan untuk mengakses fitur yang memerlukan otentikasi.

3. Pentingnya Instance `CookieRequest` Dibagikan

**Instance `CookieRequest` wajib dibagikan** ke semua komponen di aplikasi Flutter (melalui `Provider` di `lib/main.dart`) karena ia adalah satu-satunya entitas yang menyimpan **status sesi global** dan *cookie* otentikasi yang valid. Semua *widget* yang memerlukan akses terotentikasi—seperti memeriksa apakah pengguna sudah *login* (`request.loggedIn`), mengambil daftar produk pribadi (`/get-products/?filter=my`), atau memanggil fungsi *logout*—harus mengakses *instance* yang sama ini. Pembagian melalui `Provider` memastikan konsistensi dan integritas sesi di seluruh navigasi halaman.

4. Konfigurasi Konektivitas dan Konsekuensinya

Agar Flutter dapat berkomunikasi dengan Django, diperlukan konfigurasi konektivitas yang spesifik. Kita harus menambahkan **`10.0.2.2`** ke **`ALLOWED_HOSTS`** di Django karena ini adalah alamat khusus yang digunakan emulator Android untuk merujuk ke mesin *host* (komputer) tempat *server* Django berjalan. Kegagalan menambahkan alamat ini akan menyebabkan Django menolak permintaan dengan status **`400 Bad Request`** atau **`DisallowedHost`**. Selain itu, kita harus mengaktifkan **CORS** dan mengatur **`SameSite`** (*e.g.*, `CSRF_COOKIE_SAMESITE = 'None'`) pada *cookie* sesi di `settings.py`. Konfigurasi ini penting karena aplikasi *mobile* dianggap sebagai *origin* eksternal. Jika tidak dilakukan, *request* yang mengubah data akan diblokir oleh kebijakan keamanan lintas domain (CORS) atau *cookie* sesi tidak akan terkirim, menyebabkan pengguna selalu dianggap belum *login* (**`403 Forbidden`** atau **`401 Unauthorized`**). Terakhir, **izin akses internet** harus ditambahkan ke `AndroidManifest.xml` Android agar aplikasi diizinkan melakukan koneksi jaringan.

5. Mekanisme Pengiriman Data (Input hingga Tampilan)

Mekanisme ini dimulai dari sisi klien (Flutter). Pengguna memicu *event* (misalnya, membuka daftar produk). Flutter menggunakan `CookieRequest().get()` untuk memanggil *endpoint* JSON Django (`/get-products/`). Django memproses *request*, melakukan *query* ke *database* melalui model `Product`, dan mengembalikan data produk dalam format **`JsonResponse`**. Flutter menerima *response* JSON, yang kemudian diuraikan (parsed) dan dipetakan (mapped) menjadi daftar objek **`ProductEntry`** Dart. Akhirnya, *widget* **`FutureBuilder`** di `ProductEntryList` menerima objek-objek ini dan merender *widget* **`ProductEntryCard`** yang sesuai di antarmuka pengguna.

6. Mekanisme Autentikasi (Login, Register, Logout)

Mekanisme autentikasi berjalan sebagai berikut:
a.  **Register:** Pengguna mengirim data dari `RegisterPage` ke *endpoint* registrasi Django. Django membuat objek `User` baru, dan jika sukses, merespons status `200`.
b.  **Login:** Pengguna mengirim kredensial dari `LoginPage`. `request.login()` mengirim data ke *endpoint* *login* Django. Django memverifikasi dengan `authenticate`. Jika berhasil, `auth_login()` dipanggil untuk **menciptakan *session* di *server*** dan mengirimkan **`sessionid` *cookie*** ke *client*. `CookieRequest` menyimpannya, dan Flutter mengalihkan ke `MyHomePage` (menu).
c.  **Logout:** Pengguna menekan kartu **Logout**. `request.logout()` dikirim, membawa *cookie* sesi. Django memanggil `auth_logout()` untuk **menghancurkan sesi di *server*** dan meminta Flutter menghapus *cookie* lokal, kemudian mengarahkan pengguna kembali ke `LoginPage`.

7. Implementasi Checklist Secara Step-by-Step

Implementasi dimulai dengan memastikan kerangka Django siap untuk API lintas platform (CORS, `ALLOWED_HOSTS`, *views* otentikasi dan produk yang mengembalikan JSON, model `Product` dengan `ForeignKey` ke `User`). Di sisi Flutter, langkah pertama adalah mendefinisikan **Model Dart** `ProductEntry` dan mengonfigurasi **`Provider`** untuk *instance* `CookieRequest`. Selanjutnya, diimplementasikan halaman **Register** dan **Login** yang menggunakan `postJson` dan `request.login` ke *endpoint* Django masing-masing. Setelah *login*, halaman **`ProductEntryList`** dibuat untuk mengambil data produk menggunakan `CookieRequest().get()` dalam `FutureBuilder` dan menerapkan **Filter "My Product"** dengan mengelola *state* `_filterType` yang mengontrol parameter *query* (`?filter=my`). Terakhir, desain keseluruhan (`lib/screens/menu.dart`, `lib/widgets/product_card.dart`, dll.) disempurnakan untuk selaras dengan tema website (kartu putih beraksen biru, *header* yang menonjol) dan menghilangkan elemen desain khas tutorial.